Super
- 부모클래스에서 상속받은 필드나 메서드를 자식클래스에서 참조하는데 사용하는 참조변수이다 . super () -부모클래스로 치환

this - 자기자신을 스스로 참조한다 .


접근 제한자

	제한자
	클래스 ,변수, 또는 메서드의 선언부에 함께 사용해 부가적인 의미를 부여하는 키워드 
	경우에 따라 여러개를 조합하여 사용할 수 있지만 , 접근제한자의 경우 하나만 선택해서 사용해야한다 .

	접근제한자
	- 클래스 , 멤버(필드,메서드) 에 접근 가능한 범위를 제한하는 키워드
	- 객체지향 프로그래밍의 특징중 한 가지인 정보 은닉을 지키기 위한 중요한 부분이다 .
	
	- public : 제한없이 모든 패키지 , 모든 클래스에서 접근이 가능하다 .
	- protected : 같은 패키지안에서 접근가능하며 , 다른패키지라도 자식클래스라면 접근이 가능하다 .
	- default : 같은 패키지 내에서만 접근이 가능하다 .
	- private : 같은 클래스 내에서만 접근이 가능하다 .

	클래스의 접근제한자
	- 클래스는 접근제한자로 public 과 default 만 가질 수 있다 .
	- private과 protected의 경우 클래스 멤버들을 위한 접근제한자로 클래스 외부에서 접근을 막을지 말지에 대해 제한하는 용도로 사용되기 때문에 
	클래스의 접근제한자로 사용할 수 없다 . 


객체지향의 특징
- 캡슐화 (getter & setter)
객체 내부의 멤버 (필드 , 메서드 등 ) 를 객체 외부에서 볼 수 없도록 캡슐화 한다 .
접근이 필요한 경우 public  메서드를 활용해 접근하고 , 이외의 값들은 모두 캡슐화를 통해 정보를 은닉한다 .


- 상속 
미리 정의된 부모 클래스의 멤버를 자식 클래스가 물려받는다 

-다형성 
하나의 방법으로 여러객체를 호출하여 사용할 수 있다 .

- 추상화 
공통된 기능과 정보를 추출해 객체화 한다 .

	default 	
	- 접근제한자를 따로 명시하지 않는다면 클래스와 멤버들은 자동으로 default를 가진다 .
	default 로 선언된 클래스와멤버들은 같은 패키지안에서든 어디든지 접근 및 사용이 가능하나 
	다른 패키지에서는 접근이 불가능하다 .

	protected 
	- 클래스  멤버를 위한 제한자로 , 상속과 관련이 있는 제한자이다 .
	- default처럼 같은 패키지안에서 접근과 사용을 허가하지만 , 다른패키지에서의 접근을 완전히 제한하는것이 아닌 ,
 	"해당 클래스와 상속관계에 있는 자식클래스" 라면 다른패키지라도	접근 및 사용이 가능하다 .

	private 
	- 가장 사용 범위가 좁은 클래스멤버를 위한 제한자이다 .
	클래스가 public/default 이더라도 private으로 선언된 멤버들은 클래스 외부에서 접근이 불가능하다 .
	오직 선언된 클래스 내부에서만 접근하여 사용할 수 있다 .

N차 상속 (2차상속)
상속을 그 다음세대에도 넘길 수 있다 .
2차,3차,.... N차까지 상속을 이어받을 수 있다 .

final 
	final 키워드는 상수를 뜻하는 키워드로  필드앞에 선언하여 사용한다 .초기화 후 값을 바꿀 수 없으며
 	시간이지나도 처음정의된 상태가 변하지않는다는의미를 가지고있다 .
 	이 키워드는 메서드와 클래스에도 사용할 수 있다 .

	final 클래스
		- 클래스 앞에 final을 추가할 경우, 이 클래스는 상속의 마지막 클래스임을 뜻한다.
		- 어떠한 클래스도 이 클래스의 자식 클래스가 될 수 없고, 자연스럽게 이 클래스는 어떤 클래스의 부모클래스가 될 수 없다.

	final 메서드
		- 메서드 앞에 final 을 추가하게 되면 상속은 받더라도 , 오버라이딩 할 수 없는 메서드가 된다 
		- .즉, 자식 클래스이더라도 부모 클래스에 final로 선언된 메서드는 자식 클래스에서 오버라이딩 하지 못하고 있는 그대로 사용해야 한다.

	생성자에는 final 을 붙힐 수 없다 .
	- 생성자는 접근제한자만 추가할 수 있다 .
	- 따라서 클래스를 final로 선언하더라도 생성자를 final로 선언할 수 없다 .



클래스에서의 타입변환
	- 타입변환은 타입을 다른 타입으로 변환하는 것 
	- 자바에서는 다음과 같이 두가지 타입변환이 있다 .
		- 자료형 변환
		- 클래스의 객체 타입 변환 
	- 클래스의 타입변환도 마찬가지로 자동 타입변환가 강제 타입변환이 있다 .
	- 단 자료형에 비해 타입변환이 가능한 범위가 상당히 좁다 
	- 클래스의 타입 변환은 , 서로 상속관계에 있는 클래스 사이에서만 변환할 수 있다 .


	클래스의 자동 타입 변환 
	- 자료형에서의 자동 형 변환과 마찬가지로 개발자가 직접 명시하지 않아도 
	자동으로 타입변환이 일어나는 것을 ' 클래스 자동타입 변환 ' 이라고 한다 .
	- 클래스 자동타입 변환은 상속관계에 있는 자식클래스의 객체를
	부모타입으로 변환하는것을 말한다 

	부모타입 변수명 = new 자식클래스명();

	이미 만들어진 자식 객체를 부모 타입으로 변화려고 할 때는 다음과 같이 쓴다 .

	부모타입 변수명 = 자식객체 ;


	타입을 부모타입으로 변환한 객체는 , 더이상 자신의 클래스에 추가한멤버를 사용할 수 없다 .
	부모클래스에서 선언한 멤버만 사용가능하다 .
	단 , 부모 클래스의 메서드를 오버라이딩한 경우 메서드의 경우에는
	자식객체의것을 호출할 수 있다 .

	어떻게 타입변환을 해도 오버라이딩된 메서드가 호출이 될까 ??
	메서드가 실행 시점에 성격이 결정되는 동적바인딩을 하기 떄문이다 .
	프로그램의 컴파일 시점에 실행되는 메서드가 부모클래스의 것인지
	자식클래스의 것인지 알기 어렵다 .
	실행 시점에 동적 바인딩이 일어나 부모가 자식 클래스의 멤버함수에
	접근하여 실행할 수 있다 

		 동적바인딩의 작동 
		 1. 클래스 계층구조
		 자바에서 동적바인딩은 클래스 계층 구조에서 발생한다 .
		 상속하거나 인터페이스를 구현함으로써 계층을 갖는다 .
		 이 계층에서 메서드 오버라이딩이 가능하기 때문이다 .
		

		 2. 메서드 오버라이딩
		 자식클래스는 부모 클래스의 메서드를 재정의할 수 있다 .
		 이때 자식 클래스에서 부모클래스의 동일한 시그니쳐 (메서드명,매개변수개수,매개변수의 자료형) 를 가진 
		 메서드를 재정의한다 
		
		 3. 실행시 동적 바인딩
		 객체가 생성되고 메서드가 호출될 때 , 실제로 실행될 메서드는 객체의 실제 타입에 따라 결정된다 .
		 메서드 호출시 객체의 클래스 타입을 기반으로 어떤 메서드를 호출할지 동적으로 결정된다 .
		 



상속 (inheritance) 
부모클래스-> 상속해주는 클래스 
자식클래스-> 상속받는 클래스 
extends
class 자식클래스명 extends 부모클래스명 {
}

부모의 멤버와 메서드를 자식클래스가 사용할 수 있다 .


접근제한자
public : 제한없이 접근가능
protected : 같은 패키지에서 접근가능 , 다른패키지라도 자식클래스라면 접근가능(super로만 접근가능)
default : 접근제한자를 작성하지않으면 기본으로 default가 사용되며 생략된다 .
private : 같은클래스 내에서만 접근이 가능하다 .

2차 상속 

Car - > OpenCar -> Sportcar  
	->Bus -> SchoolBus 


상속의 의의
부모클래스 -> 넓은 범위의 범주 (ex:차) 

자식클래스 -> 좁은 범위의 범주 (ex: 버스,트럭,승용차,승합차)

변수 :핸들 바퀴 엑셀 브레이크 문 등등 ) 중복되는 항목들이 있을때 상속을사용한다.
메서드 ; 달린다 , 멈춘다


상속의 특징 
1.다중상속을 받는게 불가능하다 . 
(다이아몬드 문제 )             
2. 최상위 클래스는 Object다.
3. 하나의 부모클래스는 여러 자식클래스를 갖는것은 가능하다 .

오버라이딩 
1. 부모클래스의 메서드를 재정의하는것 .
2. 반환형,메서드명,매개변수를 그대로 써야한다 .
3. 내용만 재정의 해야한다 .
4. 범위는 넓혀서 사용가능 (defualt -> public ) 

super

부모클래스를 지칭하는 키워드 
super.필드 -> 부모의 필드 호출가능  ( 겹치는게 없으면 super 를 생략하고 필드만 작성가능 )
super.메서드명() -> 부모의 메서드명 -> 부모의 메서드 호출
super() -> 부모의 생성자 호출 

자식클래스의 객체가 만들어질 때 부모클래스의 멤버를 사용할 수 있는 이유 .
자식생성자 안에서 부모생성자(super())가 호출 되기 떄문이다 .


final

final 클래스 
상속이 불가능한 마지막 클래스이다 .

final 메서드
사용은 할 수 있으나 ,오버라이딩 불가능함

final 생성자 는 없음 


클래스의 타입변환 

자동타입변환
자식타입 - > 부모타입
자식클래스에 따로 추가해놨던 필드와 메서드를  사용할 수 없다 .
부모클래스에 있는것만 사용할 수 있는데 예외로 오바리이딩된 메서드는 사용할 수 있다 .

동적바인딩 - > 프로그램이 실행될 때 객체의 실제 타입에 따라 어떤 메서드가 실행되는지 결정된다 .









