자료구조 -> 여러개의 데이터를 저장할 수 있는것
List
Node 들이 나열되어있는 자료구조

Stack (
Node들이 쌓이는 구조 (후입선출 LIFO)


Queue
Node들이 줄을 서는 구조 (선입 선출 FIFO)


List,Set,Map

변수 -> 데이터를 1개 넣을 수 있음
배열 -> 배열의 크기가 생성시 고정(늘리거나 줄이는게 불가능 .)

알고리즘 -> 조회방법 , 정렬방법 , 그리디(최단경로찾기,동전 거스름돈), 분할정복 (이진탐색)

잘 짜여진 알고리즘 ?
시간복잡도 

컬렉션 프레임워크
List
index 있음
자료중복 가능

Set
index 없음 
순서 없음
중복 불가능

Map
index 는없지만 key value 쌍으로 데이터가 저장됨 {key : value}
순서대로 저장되지않고 key 중복은 불가능하지만 value 는 중복이 가능하다 . 추가할때 사용하는 메서드 put()

제네릭
타입을 미리 결정하지 않는다 .

public class 클래스명 <T>{...}
public interface 인터페이스명 <T>{...}

제네릭타입은 객체를 만들때 결정

제네릭 타입끼리는 상속이 불가능함

와일드카드
제네릭타입에 들어갈 수 있는 것은 너무 자유롭지만 
상속이 되지않기때문에 들어갈 수 있는 타입을 제한하는것

<?> : 제한없음
<? extends 상위타입 > : 상위 타입으로부터 아래 모든클래스나 인터페이스 사용가능
<? super 하위타입>  : 하위 타입부터 위 모든 클래스나 인터페이스 사용가능 


람다식
다형성 + 익명클래스
이름없는 함수를 만든다 .

함수형 인터페이스 
- 추상메서드가 한개만 들어있는 메서드 


매개변수가 0~2개 있는 메서드
반환형이 있거나 없는 메서드 


접근제한자 , 반환형 함수명 제거하고 화살표로 표현

인터페이스명 변수명  = ( 매개변수 ) -> { 명령 }

변수명.메서드명() ;

매개변수가 한개면 소괄화 생략가능 

str - > {System.out.println(str)};

두개명 자료형은 생략 가능 
(x,y) -> {x+y;};

중괄호는 반환값 없으면 생략 가능
return과 함께 생략가능

매개변수에 넣을 수 있음
반환값에 넣을 수 있음 

스레드

프로세스가 독립적으로 작동할 수 있게 해주는것 

스레드를 생성하는법 
1. Thread클래스의 상속
2. Runnable인터페이스의 구현

run() 메서드를 오버라이딩 하여 독립적으로 실행하고싶은 내용을 정의

main 에서 start() 메서드로 실행 

Runnable 인터페이스로 구현한 스레드의 경우 main 에서Thread 객체를 생성한 후
 생성자에 우리가 생성한 스레드 객체를 전달하여 start()메서드 호출


sleep(밀리초) -> 주어진 초 동안 스레드 멈춤 
wait() -> 스레드 멈춤
notify() -> 멈춘 스레드를 재시작 


 








