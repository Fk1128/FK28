TreeSet
- 이진탐색트리 중에서도 성능을 향상시킨 레드블랙트리로 구현되어있다 .
- 레드블랙트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽 큰 값을 가지는 노드는 오른쪽으로 배치한다 .
- 데이터의 추가나 삭제시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞춰준다 .

Map
- List,Set 과 달리 Map 인터페이스가 별도로 존재하며 , 데이터를 List계열 컬렉션과 다르게 처리한다.
- 데이터를 Key와 Value 로 구분하여 저장하는 key-value 방식을 사용한다 .
- index는 없지만 Key를 통해서 값을 검색하기 때문에 ArrayList와 같이 많은양의 데이터를 조회하는 데 있어 매우 뛰어난 성능을 발휘

HashMap
- map 을 구현하고 있는 자식 클래스에서 가장 많이 사용하는 구현체이다 .

Generic

 제네릭 사용시 주의사항 .
	1. 제네릭 타입의 객체는 생성할 수 없다 .
	제네릭타입 자체로 타입을 지정하여 객체를 생성하는 것은 불가능하다 .
ex) class Sample<T> {
    public void someMethod() { //// Type parameter 'T' cannot be instantiated directly 타입 매개변수 T는 직접 객체생성하는것은 불가능하다.
         T t = new T(); == x
    }
}


2. Static멤버에 제네릭 타입이 올 수 없음
	-static 멤버는 클래스가 동일하게 공유하는 변수로서 
	제네릭 객체가 생성되기도전에 이미 자료타입이 정해져 있어야 하기 때문이다 .

	2-1 static 메서드의 반환타입으로 사용이 불가능

ex) class Student<T> {
    private String name;
    private int age = 0;

    // static 메서드의 반환 타입으로 사용 불가
    public static T addAge(int n) {

    }
}

	2-2 static 메서드의 매개변수 타입으로 사용이 불가능하다.

ex) class Student<T> {
    private String name;
    private int age = 0;

    // static 메서드의 매개변수 타입으로 사용 불가능
    public static void addAge(T n) {

    }
}




3. 제네릭으로 배열 선언 주의점
- 기본적으로 제네릭 클래스 자체를 배열로 만들 수는 없다 .

ex) class Sample<T> { 
}

public class Main {
    public static void main(String[] args) {
        Sample<Integer>[] arr1 = new Sample<>[10];
    }
}

제네릭 타입에 클래스가 들어온다는 것은 , 클래스끼리 상속을 통해 관계를 맺는 다형성이 그대로 적용되지않을까 ?

중첩타입 파라미터
- 제네릭 객체를 제네릭 타입 파라미터로 받는 형식으로 표현할 수 있다 .
- ArrayList 자체도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기때문에 중첩 형식으로 사용할 수 있다 .



제네릭 인터페이스
-인터페이스를 구현(implements)한 클래스에서도 오바리이딩한
메서드를 제네릭타입에 맞춰서 똑같이 구현해야 한다 .


제네릭 메서드 
메서드에서만 적용되는 제네릭타입


제네릭타입 범위 한정하기
- 제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일시에 정하여 타입예외에 대한 안정성을 확보하는것은 좋지만 
타입예외에 대한 안정성을 확보하는것은 좋지만 문제는 너무 자유롭다는점이다 .


타입한정 키워드 extends

<T extends 제한타입 >

extends 키워드 뒤에 올 타입은 일반클래스 , 추상클래스 , 인터페이스 
모두 가능하다 .

다중타입한정
- 만일 2개 이상의 타입을 동시에 구현한 경우 타입제한을 하고싶다면 & 연산자를 사용한다
- 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입에 대상이되게한다 .
- 단 자바에서는 다중상속을 지원하지 않기 떄문에 클래스로는 다중 extends는 불가능하고 오로지 인터페이스로만이 가능하다 .



제네릭의 형변환 
- 제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다 .
자연스럽게 다형성이 적용될것이라고 생각할 수 있지만 , 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능하다 .


제네릭타입은 상하관계가 없다 .
제네릭 타입변수끼리는 아무리 상속관계에 놓인다 한들 형변환이 불가능하다 .

제네릭 와일드카드
제네릭 간의 형변환을 성립되게 하기 위해서는 제네릭에서 제공하는 와일드카드 문법을 이용해야 한다 .
<?> : Unbounded WilCards(제한없음)
- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있다 .

<? extends 상위타입> : Upper bounded WildCards(상위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 , 상위타입의 하위 타입만 올 수 있다 .

<? super 하위타입> : Lower Bounded Wildcards(하위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위 타입의 상위 타입만 올 수 있다.


람다식
JDK1.8부터 함수형 프로그래밍 '람다식(Lambda expression)'을 지원하고 있다.
람다식은 이름이 없는 익명 함수(anonymous function)를 만들기 위한 표현식을 말한다.
자바는 객체를 기반으로 프로그램을 구현하는 객체 지향 프로그램이다.
따라서 클래스를 먼저 생성하고, 클래스 안에 메서드와 객체를 선언해 사용해야 한다.
하지만 함수형 프로그래밍은 객체 지향 프로그램과 달리 함수만을 구현하고 실행할 수 있는 개발방식이다

람다식이 도입된 이유
함수형 프로그래밍 방식
자바에서는 함수형 프로그래밍 방식이 적용되지 않았다.
자바 공부할 때 함수는 어디에 만들었는가 클래스를 나누어서 작성했었다.
자바 -> 함수가 독립적이지 않다. -> 반드시 객체를 만들어서 호출


람다식 문법
람다식 문법은 기존의 자바 문법과는 달라서 객체 지향 프로그래밍에 익숙한 개발자들은 다소 생소할 수 있다.
하지만 문법이 매우 간결해지고, 원하는 결과를 쉽게 집계할 수 있어 익숙해지면 큰 장점이 있다

int add(int x, int y){
	return x+y;
}

위 함수를 람다식으로 표현하기 


( x,  y) -> {return x + y'}
매개변수	함수 구현

메서드의 이름과 반환 타입을 제거하고 화살표(->)를 이용해 구현한다.


소괄호 생략하기
람다식 문법에서는 파라미터의 자료형을 생략할 수 있다
파라미터가 한 개인 경우에는 소괄호도 생략할 수 있다.
그러나 파라미터가 두 개 이상일 경우에는 생략할 수 없다.

(String str ) -> {System.out.println(str);}

str - > {System.out.println(str);}

중괄호 생략하기
함수의 반환형이 void라면 중괄호도 생략할 수 있다.
(x,y) -> {System.outprintln(x+y);}
	↓ return이 없는 경우
(x,y) -> System.out.println(x+y); //중괄호 생략 가능
return 생략하기
중괄호 안의 구현 코드가 return문만 존재할 때는 중괄호와 return을 모두 생략할 수 있다.
(x,y) -> {return x+y;}
	↓ return문장만 있는 경우
(x,y) -> x+y; 

함수형 인터페이스
객체 지향 프로그램에서 인터페이스를 사용하려면 인터페이스를 클래스에서 구현한체를 만든뒤 사용해야 한다.
람다식은 위와 같은 과정을 생략할 수 있다.
단, 람다식을 이용해 인터페이스를 사용할 경우, 인터페이스안에는  하나의 추상메서드만을 작성할 수 있다.
람다식을 구현하기 위해서는 먼저 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언해야 한다.
오직 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟이 될 수 있는데
이를 '함수형 인터페이스'라고 한다.


