
다중인터페이스 구현

우리는 하나의 클래스로 여러 개의 인터페이스를 구현할 수 있다.
선언한 모든 인터페이스에 대한 추상 메서드를 모두 구현해 줘야 한다.
[접근제한자]class 클래스명 implements 인터페이스1,인터페이스2{
	//필드
	//생성자
	//인터페이스1에 대한 구현 메서드
	//인터페이스2에 대한 구현 메서드
}

인터페이스 상속
인터페이스끼리 상속관계를 만들 수 있다.
클래스의 상속과 만찬가지로 extends키워드를 사용하며, 다중 상속이 가능하기 때문에 콤마(,)를 이용해서 다음과 같이 선언한다
인터페이스 상속을 선언하면, 하위 클래스는 상위 클래스의 모든 멤버를 상속받게 된다.
따라서 만약 하위 인터페이스를 구현하는 클래스가 있다면, 해당 클래스는 하위 인터페이스의 추상메서드를 포함하여 상위 인터페이스르의 추상 메서드까지 구현해야 한다.
[접근제한자] interface 인터페이스명 extends 인터페이스1, 인터페이스2,...{

}
=------------------------------------------------------------------------------------------------`	

내부클래스 
- 클래스 안에 만들어진 또 다른 클래스로 중첩 클래스라고도 부른다 .
- 클래스 안에 다른 클래스를 선언하는 이유는 두 개의 클래스가 서로 긴미랗나 관계를 맺고 있기 떄문이다 .

	내부클래스의 장점 
	- 두 클래스 멤버들 간에 손쉽게 접근할 수 있다 .
	- 불필요한 클래스를 감춰 코드의 복잡성을 줄일 수 있다 .

public class OuterClass{ 외부클래스
	class innerClass{ 내부클래스 
	
	}
}


	내부클래스의 종류 

	인스턴스 클래스 
		- 외부클래스의 필드와 같은 위치에 선언
		- 주로 외부클래스의 클래스 멤버 변수와 관련된 작업에 사용될 목적으로 선언 


	정적클래스

		- 클래스의 클래스변수처럼(정적변수) 
		- 내부클래스에 static 을 붙힌 클래스 

	지역 클래스	
		- 외부 클래스의 메서드 내부에서 선언하여 사용
		- 메서드 영역에서 선언되기 때문에 메서드 내부에서만 사용 가능

인스턴스 클래스

	- 외부클래스 내부에서 생성하고 선언되어 사용하는 클래스를 의미한다 .
	- 인스턴스 변수(필드) 와 같은위치에 선언하며 , 외부 클래스의 필드 (인스턴스멤버) 멤버처럼 다루어진다.
	- 주로 외부클래스의 멤버들과 관련된 작업에 사용될 목적으로 선언된다 .


	public class Outer {
		private String name ; // 필드

		//인스턴스 클래스가 들어갈 수 있다 .
		public class Inner {
			private int age 
		}
	}

	내부 클래스도 외부 클래스 안에 생성되는것 외에는 별도의 클래스이기 때문에 파일이 컴파일되면 별도로 생성된다 .

	인스턴스 클래스의 객체화 
	- 인스턴스 클래스는 기본적인 내부클래스이다 .
	- 외부 클래스 안에 생성되기 떄문에 , 클래스를 사용하려면 외부 클래스의 객체가 생성된 상태에서 객체를 생성할 수 있다 .

	Outter outer = new Outer () ; // 외부클래스 객체 생성 
	Outer.Inner inner = Outer.new Inner();
						(  . == ~의)
 	


정적 내부 클래스(static class)
	
	- 클래스 안에 정적변수를 선언할 수 있는것 처럼 클래스도 정적 내부 클래스를 만들 수 있다
	- 필드와 마찬가지로 staic키워드를 사용해 클래스를 선언한 후 정적 내부 클래스를 생성한다 . 
	- 주로 외부 클래스의 static 메서드에서 사용될 목적으로 만든다 .

public class Outer{
	private String name ;
	public static class Inner{
		private String name ;
	}
}
- 외부 클래스의 필드 또는 메서드를 정적 내부 클래스 안에서는 사용할 수 없다 .

public class Outer {
	private int val1 ; 일반적인 필드
	private static int cnt = 1 ; 정적변수 

	public static class Inner{   	// 정적 내부클래스 
		public void displayOuterInfo()
		System.out.println(val1);  // 에러
		System.out.println(cnt);  // 정상실행

		//public void add(){
		// int result = val1 + 10 ;  //== 에러
		
	}
}
}
- 정적 내부 클래스는 정적변수 또는 정적메서드를 호출하는것은 가능하다 .

정적 내부클래스의 객체 생성 
Outer.Inner in = new Outer.Inner();


지역클래스 (local class)

	- 외부 클래스의 메서드 안에서 선언하여 사용하는 클래스 
	- 메서드 내에서 선언되기 때문에 해당 클래스는 메서드 내에서만 사용할 수 있다 .
	- 메서드 실행이 끝나면 해당 클래스도 사용이 종료된다 .

public class LocalClass{
	public void print() {
	//////////////////////	
	class A {

	}

	A a= new A  ();
	//////////////////////
	}
}



내부클래스의 접근 제한 
	 - 내부 클래스도 클래스이기 때문에 접근제한자를 붙여 사용할 수 있다 .


지역클래스의 접근제한 
	- 지역클래스는 메서드 내에서 선언되어 사용한다 .
	- 보통 메서드가 종료되면 클래스도 함께 종료되지만 
	메서드와 실행되는 위치가 다르기 떄문에 종료되지 않고 남아있을수도 있다 .
	- 그래서 지역클래스에서 메서드 내의 변수를 사용할 떄는 변수를 복사해 사용한다 .
	- 이러한 이유로 지역 클래스에서 메서드의 변수를 사용할 때 변수가 변경되면 오류가 발생한다 .

익명클래스(anonymous class ) 
	- 이름이 없는 클래스 
	- 익명클래스는 클래스의 선언과 객체의 생성을 동시에 하므로 
	한번만 사용할 수 있다 .
	- 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다 .
	- 따라서 생성자를 선언할 수도 없으며 , 둘 이상의 인터페이스를 구현할수도 없다 ..


예외처리 

에러(error)와 ㅇ예외(exception)
프로그램을 실행하다보면 갑자기 프로그램이 종료되거나 , 어떤 원인에 의해 잘못 동작하여 오류 메세지가 나타는 등 예기치못한 오류가 발생한다 .
에러는 우리가 이해할 수 없는 해결할 수 없는 시스템 에러가 발생해 프로그램이 종료된 경우이며 
예외는 프로그램 사용 중 발생한 오류를 개발자가 처리 해 메시지가 출력된 경우이다 .

	에러(error) 
	- 시스템에 비정상적인 상황이 생겼을 때 발생한다 .
	- 외부요인일수도 잇고 , 프로그램 구동중에 발생하는 치명적인 오류일수도 있다 .
	이러한에러들은 개발자가 예측하거나 처리할 수 없는 영역이다 .

	OutOfMemoryError		프로그램 실행 중 메모리 부족
	IOError			입출력 에러
	StackOverFlowError	가용 메모리 부족 현상, 재귀 호출 문제시 발생

	예외(exception)
	- 대체로 프로그램 구동중에 나타는 오류들
	- 문법적으로는 문제가 없어보이지만 실제 운영 중에 생기는 문제들 .
	- 체크예외와 비체크예외 두가지가 있다 .



	체크예외
		- 자바소스를 컴파일 하는 과정에서 검사한다 .
		- 보통 문법적으로 강제하여 예외 처리를 해야하는 경우 .
		 
		
	비체크예외
		- 컴파일 과정에서 검사하지 않으므로 사용자의 경험이나 
		테스트로 찾아야 하는 경우
	
	예외클래스 
	자바는 객체지향 언어이고 따라서 프로그램에서 발생하는 예외들은 클래스 형태로 제공된다 .

	NullPointerException 
	- 객체가 제대로 생성되지 않은 상태에서 사용할 경우 발생한다 .
	- 객체를 선언하면 ,주소를 갖게되고 , 그것을 통해 객체에 접근해 값을 가져온다 .
	- 객체변수는 정의되었는데 메모리에 올리지않았을 때  예외가 발생한다 .


예외처리 문법
	- 예외가 발생했을 때 , 어떻게 예외를 처리하는지 방법을 보자 

	예외처리 과정
	1. 코드 진행 중 예외가 발생하면 JVM 에게 알린다.
	2. JVM 은 발생한 예외를 분석하여 알맞은 예외클래스를 생성한다 .
	3. 생성된 예외 객체를 발생한 지점으로 보낸다 .
	4. 예외가 발생한 지점에서 처리하지 않으면 프로그램은 비정상 종료된다 .


try - catch 구문 
	- 예외를 처리하는 가장 기본 문법은 try-catch 문이다.
	- 예외가 발생할 가능성이 있는 코드는 try{} 영역 안에 작성하고 
	catch메서드는 시스템으로부터 넘어오는 예외 클래스를 받아서 처리한다 .

		try{
			예외가 발생할 가능성이있는 코드
		} catch(예외클래스명 e){ 예외처리 코드 

		}



	다중catch 사용하기
	- 프로그램을 구동할 때 하나의 예외만 발생한다면 어렵지 않다 . 하지만 try구문 안에서 예외는 다양하게 발생할 수 있다 .
	- 만약 기존과 같은 방법으로 처리한다면 예외를 제외하고는제대로 처리할 수 없다 .
	- 이때 다중 catch문을 사용하여 예외별로 예외코드를 다르게 처리할 수 있다 .
		

	Finally
	- Finally 블록은 예외 발생 유무와 상관없이 실행되는 구문이며 생략할 수 있다 .
	- 예외를 처리할 때 , 예외와 상관없이 반드시 처리해야 하는 구문들을 작성할 때 사용한다 .
	- 보통 외부 연동이나 예외가 발생해도 정상 종료되어야 할 구문들에서 사용한다 .


예외 던지기
	- 메서드 내부에서 예외를 처리하지않고 미룬후 , 해당메서드를 호출한쪽에서 예외를 처리하는방법
throws
메서드 뒤에 throws 키워드를 사용하여 던지기 할 예외 객체를 붙여주면 된다 .
예외 객체는 여러개를 던질 수 있으며 , 여러개를 던질시 콤마(,)로 구분하여 나열해준다 .




-----------------------------------------------------------------------------------------------------------------------------------------------
8/12 오전 정리 

상속
부모클래스 -> 자식클래스 필드 , 메서드를 사용할 수 있도록 하는것 .
1. 중복되는 코드를 제거 

부모클래스 (넓은범위의 개념) 
자식클래스 (부모클래스보다 상대적으로 좁은범위의 개념 )


오버라이딩
부모 메서드의 시그니처 (접근제한자 , 반환형 , 메서드명 , 매개변수) 를 그대로가지고 내용만 자식의 상황에맞게 '재정의' 하는것 .


클래스 타입변환
상속관계에서만 일어날 수 있는 타입변환

자동타입변환
자식 - > 부모
자식클래스에 추가로 만들어놨던 필드나 메서드를 사용할 수 없다 .
단 , 오버라이딩 된 메서드만 사용가능 .


강제타입변환 
자식에서 부모타입으로 타입변환을 했지만 자식클래스에 정의된 필드나 메서드를 사용하고싶을 때 변환한다 .
부모타입으로 변환된 자식클래스를 강제로 다시 자식타입으로 변환시킨다 .
부모 - > 자식 


다형성 
public class Phone{ // 휴대폰에 대한 정의
	String number ; - 
	int series ;
	String color;
	String brand ; 
}
public class Samsung extends Phone{

}


public class Apple extends Phone {

}

public class Nokia extends Phone {

}

public class LG extends Phone {

}
부모타입		자식객체 ( 자동타입변환 )
Phone p = new Samsung();
Phone p2 = new LG();
Phone p3 = new Apple();

추상화(abstract)
어차피 상속용으로 만들거고 부모 클래스는 딱히 필요가 없음

추상클래스를 상속받은 클래스는 추상메서드를 반드시 오버라이딩 해야한다 .

추상클래스는 직접 객체화 시키는게 불가능하다 .


인터페이스

상수 , 추상메서드 밖에없음
매개체 역할을 함 



외부클래스의 객체생성
Outer outer = new Outer();
Outer.inner  = Outer.new inner ();



내부클래스

인스턴스 클래스
외부클래스 안쪽에서 만들어진 클래스
필드와 같은선상에 만들어짐 .

정적클래스 
static 키워드가 붙은 내부클래스

지역클래스 
외부클래스의 메서드안에서 정의된 클래스 



예외처리 

오류가 발생할 수 있다고 예상할 수 있지만 막을 수 없는것 .




ArrayIndexOutofBounds  - 인덱스 벗어남 
Arithmatic - 정수를 0으로 나누려고 함
NullPointer - 객체가 메모리 안올라감
InputMissmatch - 타입이 안맞음 


try{ 
 예외가 발생할 수 있는 코드
}catch(예외객체 ){ // 다형성을 이용해서 Exception e 객체가 자식객체를 다 받을수 있음 
발생한 예외를 처리하는 코드 
}




try {

}catch(예외객체) {

}catch(예외객체) {

}catch(예외객체) {

} finally{ - > 예외가 발생하던 발생하지않던 무조건 실행하는 영역

}



예외던지기
머세드 안에서 예외가 발생했을 때 안에서 처리하는게 아닌
메서드를 호출한 쪽에서 처리하는방식

메서드의 매개변수와 중괄호 사이에thorws 키워드를 작성하고

예외객체를 작성한다

public void method(매개변수) throws InputMissmatchException ... {

}











